from collections import deque


class Node(object):
    """Wrapper for coordinates, representing each point in the maze."""

    def __init__(self, x, y, is_wall):
        self._is_wall = is_wall
        self.x = x
        self.y = y

    def __eq__(self, other):
        return self.x == other.x and self.y == other.y

    def __hash__(self):
        return self.x ^ self.y

    def is_wall(self):
        return self._is_wall


class Maze(object):
    """Wrapper for provided maze. Contains methods to solve for shortest path."""

    def __init__(self, maze):
        self.maze = maze
        self.num_rows = len(self.maze)
        self.num_cols = len(self.maze[0])
        self.__init_maze_nodes(maze)

    def __init_maze_nodes(self, maze):
        """Populates the internal "maze" list with corresponding Node objects

        Args:
            maze (:obj:`list` of :obj:`list` of `int`): maze array as provided to solution.
        """
        for y in range(self.num_rows):
            for x in range(self.num_cols):
                is_wall = maze[y][x] == 1
                node = Node(x, y, is_wall)
                self.maze[y][x] = node

    def __breakable_walls(self):
        """ Identifies wall nodes that would connect two open spaces if broken

        Yields:
            breakable_walls (:obj:`list` of :obj:`Node`): wall objects that would connect two paths if broken
        """
        # for every wall, check neighbors.
        breakable_walls = []
        for y in range(self.num_rows):
            for x in range(self.num_cols):
                if self.maze[y][x].is_wall():
                    wall = Node(x, y, True)
                    num_open_neighbors = sum(not n.is_wall() for n in self.__get_neighbors(wall))
                    if num_open_neighbors >= 2:
                        breakable_walls.append(wall)
        return breakable_walls

    def __find_distances(self, start):
        """ Records distance of each node from the given start (without breaking walls)

        Args:
            start (:obj:`Node`): Starting node

        Yields:
            distance (dict formatted as {Node: int}): distances relative to the start
        """
        open_nodes = deque([start])
        distance = {start: 1}

        while open_nodes:
            current = open_nodes.popleft()

            for neighbor in self.__get_neighbors(current):
                if neighbor.is_wall():
                    continue
                if neighbor not in distance.keys():
                    distance[neighbor] = distance[current] + 1
                    open_nodes.append(neighbor)

        return distance

    def __get_neighbors(self, node):
        """Return the neighbors of the given node

        Args:
            node (Node): Node object to find neighbors of

        Yields:
            neighbors ([Node]): List of Nodes that are neighbors to input
        """
        neighbors = []
        adjacent = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        for a in adjacent:
            new_x = node.x + a[0]
            new_y = node.y + a[1]

            # make sure to stay within list indices
            if new_x > self.num_cols - 1 or new_x < 0:
                continue
            if new_y > self.num_rows - 1 or new_y < 0:
                continue

            neighbors.append(self.maze[new_y][new_x])
        return neighbors

    def find_shortest_path(self):
        """Finds shortest path in maze, given ability to break one wall

        Yields:
            min_path_length (int): the smallest path given ability to break one wall
        """
        # Record distances from the entrance AND exit
        start = Node(0, 0, True)
        end = Node(self.num_cols - 1, self.num_rows - 1, True)
        distances_from_start = self.__find_distances(start)
        distances_from_end = self.__find_distances(end)

        min_path_length = 10000000

        # See if breaking any wall will reduce the shortest path length
        breakable_walls = self.__breakable_walls()
        for wall in breakable_walls:
            neighbors = self.__get_neighbors(wall)

            # The node must be touching beg and ending paths
            adj_to_beg = any([n in distances_from_start.keys() for n in neighbors])
            adj_to_end = any([n in distances_from_end.keys() for n in neighbors])
            if not adj_to_beg or not adj_to_end:
                continue

            # Calculate length of path generated by connecting paths
            min_start = min([distances_from_start[n] for n in neighbors if n in distances_from_start.keys()])
            min_end = min([distances_from_end[n] for n in neighbors if n in distances_from_end.keys()])

            new_path_length = min_start + min_end + 1
            min_path_length = min(min_path_length, new_path_length)

        # If no walls, return the distance to end, if possible, else return big path
        if len(breakable_walls) == 0:
            if end in distances_from_start.keys():
                return distances_from_start[end]
        return min_path_length


def solution(grid):
    maze = Maze(grid)
    return maze.find_shortest_path()
